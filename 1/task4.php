<?php
/*
    Задача №4
    Проведите рефакторинг, исправьте баги и продокументируйте в стиле PHPDoc код,
    приведённый ниже (таблица users здесь аналогична таблице users из задачи №1).
    Примечание: код написан исключительно в тестовых целях, это не "жизненный пример" :)

    function load_users_data($user_ids) {
        $user_ids = explode(',', $user_ids);
        foreach ($user_ids as $user_id) {
            $db = mysqli_connect("localhost", "root", "123123", "database");
            $sql = mysqli_query($db, "SELECT * FROM users WHERE id=$user_id");
            while($obj = $sql->fetch_object()){
                $data[$user_id] = $obj->name;
            }
            mysqli_close($db);
        }
        return $data;
    }
    // Как правило, в $_GET['user_ids'] должна приходить строка
    // с номерами пользователей через запятую, например: 1,2,17,48
    $data = load_users_data($_GET['user_ids']);
    foreach ($data as $user_id=>$name) {
        echo "<a href=\"/show_user.php?id=$user_id\">$name</a>";
    }

    Плюсом будет, если укажете, какие именно уязвимости присутствуют в исходном варианте
    (если таковые, на ваш взгляд, имеются), и приведёте примеры их проявления.
*/

##############################################################################################


/*
 * Функция возвращает данные пользователей
 * @param string $user_ids пример входа: '1,2,17,48'
 * @return array || null результирующие данные пользователей
 */
function load_users_data($user_ids)
{
    // инициализация переменных начальными значениями
    $user_ids = explode(',', $user_ids);
    $data = null;

    // если массив идентификаторов не пустой, тогда...
    if (!(empty($user_ids))) {
        // установить подключение к БД
        $db = mysqli_connect("localhost", "root", "123123", "database");

        // для каждого запрошенного пользователя
        foreach ($user_ids as $user_id) {
            // формирование строки запроса
            $sql = mysqli_query($db, "SELECT * FROM users WHERE id=$user_id");
            $sql = mysqli_escape_string($db, $sql);

            // сохранение данных конкретного пользователя
            while ($obj = $sql->fetch_object()) {
                $data[$user_id] = $obj->name; // [ '2' => 'name', '17' => 'name',... ]
            }

        }

        // закрыть соединение с БД
        mysqli_close($db);
    }

    return $data;
}

// Как правило, в $_GET['user_ids'] должна приходить строка
// с номерами пользователей через запятую, например: 1,2,17,48
$data = load_users_data($_GET['user_ids']);
if ($data !== null) {
    foreach ($data as $user_id => $name) {
        echo "<a href=\"/show_user.php?id={$user_id}\">{$name}</a>";
    }
}


// не следует создавать/закрывать новое соединение с БД:
// 1) - на каждой итерации внешнего цикла во избежание излишней нагрузки;
// 2) - если исходный массив $user_ids пустой, подключение излишне и в этом случае

// элементы исходного массива $user_ids могут быть не того типа, которые ожидается получить после выполнения explode,
// параметр $user_ids должен быть именно строкой.
// безопаснее разработать алгоритм контроля типа данных, либо воспользоваться встроенными средствами языка,
// поскольку есть договоренность какого типа данные должны поступать на входе в качестве параметров функции.

// итерировать $user_ids следует только при условии, что переменная $user_ids не пустая

// mysqli_escape_string() для предотвращения sql-инъекций пригодится (в query строке)

// если нечего итерировать, тогда что такое переменная $data?
// она должна быть проинициализирована в начале функции хотя бы null-значением

// во избежание "грубых" недоразумений с запросами к БД вполне можно обернуть запрос в конструкцию try catch,
// дабы из-за лишней детализации ошибок пользователь с плохими намерениями ничего не усугубил случай с ошибкой